<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Match-3 — 6x6</title>
<style>
  :root{
    --bg1: #9fe7d0;
    --bg2: #6dd0f2;
    --panel: rgba(255,255,255,0.85);
    --accent: #0b6b8f;
    --tile-size: 64px;
    --gap: 8px;
    --cols: 6;
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body{
    background: linear-gradient(135deg,var(--bg1),var(--bg2));
    display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
    padding:18px 12px 96px;box-sizing:border-box;
  }
  .top-bar{
    width:100%;max-width:520px;margin-bottom:12px;
    display:flex;align-items:center;justify-content:space-between;
    gap:12px;
  }
  .panel{
    background:var(--panel);
    border-radius:12px;padding:10px 14px;
    box-shadow:0 6px 18px rgba(10,10,20,0.12);
    display:flex;align-items:center;gap:12px;
  }
  .title{font-weight:600;color:var(--accent);font-size:18px}
  .score-level{display:flex;flex-direction:column;align-items:flex-end}
  .score{font-size:16px;color:#08323f}
  .level{font-size:12px;color:#2b6a7b}
  /* board */
  .board-wrap{width:100%;max-width:520px;display:flex;justify-content:center;margin-bottom:16px}
  .board{
    background:rgba(255,255,255,0.06);
    padding:var(--gap);
    border-radius:14px;
    display:grid;
    grid-template-columns: repeat(var(--cols), var(--tile-size));
    grid-template-rows: repeat(var(--cols), var(--tile-size));
    gap: var(--gap);
    box-shadow: inset 0 -6px 14px rgba(0,0,0,0.08);
    touch-action: none;
  }
  .cell{
    width:var(--tile-size);height:var(--tile-size);
    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    border-radius:10px;
    position:relative;overflow:visible;
    display:flex;align-items:center;justify-content:center;
  }
  .gem{
    width:80%;height:80%;transform-origin:center center;
    transition: transform 180ms cubic-bezier(.2,.9,.2,1), top 200ms;
    position:absolute;will-change:transform, top, left;
    display:flex;align-items:center;justify-content:center;
  }
  .gem svg{width:100%;height:100%}
  /* gem types */
  .type-0 svg path{fill:#5de0d8;stroke:#0a6b6b;stroke-width:1}
  .type-1 svg path{fill:#ffd166;stroke:#b37a00;stroke-width:1}
  .type-2 svg path{fill:#9b5cff;stroke:#3f1b62;stroke-width:1}
  .type-3 svg path{fill:#ff6b6b;stroke:#7b1414;stroke-width:1}
  .type-4 svg path{fill:#4ecdc4;stroke:#115e59;stroke-width:1}
  .type-5 svg path{fill:#ffe066;stroke:#a97f00;stroke-width:1}
  /* highlight while moving */
  .moving{transition: transform 160ms cubic-bezier(.2,.9,.2,1);z-index:50;box-shadow:0 10px 30px rgba(10,10,30,0.25);transform:scale(1.05)}
  /* remove animation - fly down */
  .remove{
    transition: transform 520ms cubic-bezier(.0,.9,.2,1), opacity 520ms;
    transform: translateY(120%) rotate(30deg) scale(0.65);
    opacity:0;
  }
  /* bottom nav */
  .bottom-nav{
    position:fixed;left:0;right:0;bottom:10px;display:flex;justify-content:center;
    pointer-events:none;
  }
  .tabs{
    display:flex;gap:12px;background:var(--panel);padding:8px;border-radius:16px;
    box-shadow:0 10px 30px rgba(5,10,20,0.12);pointer-events:all;
  }
  .tab{
    min-width:120px;padding:8px 12px;border-radius:10px;display:flex;align-items:center;gap:10px;cursor:pointer;
    user-select:none;justify-content:center;color:#06414b;font-weight:600;
  }
  .tab.active{background:linear-gradient(180deg,white,rgba(255,255,255,0.9))}
  /* profile */
  .profile{
    width:100%;max-width:520px;display:none;flex-direction:column;align-items:center;gap:12px;
  }
  .profile .card{
    width:100%;background:var(--panel);border-radius:12px;padding:18px;display:flex;flex-direction:column;align-items:center;gap:10px;
  }
  .profile .avatar{
    width:120px;height:120px;border-radius:14px;background:linear-gradient(135deg,#fff,#f0f6f7);display:flex;align-items:center;justify-content:center;font-size:42px;color:#0b6b8f;font-weight:700;
    box-shadow:0 8px 20px rgba(10,10,30,0.12);
  }
  .profile .name-input{padding:8px 10px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);width:60%;text-align:center}
  .level-big{font-size:22px;color:#08323f;font-weight:700}
  .small-muted{font-size:12px;color:#2b6971}
  /* level progress */
  .progress{
    width:100%;height:10px;background:rgba(10,10,10,0.05);border-radius:10px;overflow:hidden;
  }
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,#ffd166,#ff6b6b);width:0%}
  /* responsive */
  @media (max-width:540px){
    :root{--tile-size:54px}
    .tab{min-width:100px}
  }
</style>
</head>
<body>
  <div class="top-bar">
    <div class="panel title">Match-3: Драгоценные фишки</div>
    <div class="panel score-level">
      <div class="score" id="score">Очки: 0</div>
      <div class="level" id="levelText">Уровень: 1</div>
    </div>
  </div>

  <div class="board-wrap">
    <div id="gameView" class="board" tabindex="0" aria-label="game board"></div>
  </div>

  <!-- Profile -->
  <div id="profileView" class="profile">
    <div class="card">
      <div class="avatar" id="avatarInitial">U</div>
      <input id="nameInput" class="name-input" placeholder="Введите имя" />
      <div class="level-big" id="profileLevel">Уровень 1</div>
      <div class="small-muted">Прогресс до следующего уровня</div>
      <div class="progress" style="width:90%">
        <i id="levelProgress"></i>
      </div>
    </div>
  </div>

  <!-- bottom tabs -->
  <div class="bottom-nav">
    <div class="tabs">
      <div id="tabGame" class="tab active">Игра</div>
      <div id="tabProfile" class="tab">Профиль</div>
    </div>
  </div>

<script>
/*
  Match-3 game (6x6)
  - grid: 6x6
  - gem types: 6 (shapes/colors)
  - swipe/mouse drag and touch support
  - animations: swap, fall, remove (fly down)
  - save/load to localStorage
  - score & level. Level increases by thresholds
*/
(() => {
  const COLS = 6, ROWS = 6;
  const boardEl = document.getElementById('gameView');
  const scoreEl = document.getElementById('score');
  const levelTextEl = document.getElementById('levelText');
  const nameInput = document.getElementById('nameInput');
  const avatarInitial = document.getElementById('avatarInitial');
  const profileLevel = document.getElementById('profileLevel');
  const levelProgressBar = document.getElementById('levelProgress');

  let state = {
    grid: [], // ROWS x COLS
    score: 0,
    level: 1,
    playerName: 'Игрок',
  };

  const GEM_TYPES = 6;
  const SAVE_KEY = 'match3_state_v1';

  const levelThreshold = lvl => 100 + (lvl-1)*150; // points to next level

  /* --- Utilities --- */
  function randInt(n){ return Math.floor(Math.random()*n); }
  function deepCopyGrid(g){ return g.map(r => r.slice()); }

  /* --- Initialize / Save / Load --- */
  function initState(){
    const saved = localStorage.getItem(SAVE_KEY);
    if(saved){
      try{
        const parsed = JSON.parse(saved);
        if(parsed && parsed.grid && parsed.grid.length === ROWS){
          state = parsed;
          renderAll();
          return;
        }
      }catch(e){ console.warn('load failed',e) }
    }
    // fresh
    state.grid = [];
    for(let r=0;r<ROWS;r++){
      state.grid[r] = [];
      for(let c=0;c<COLS;c++) state.grid[r][c] = randInt(GEM_TYPES);
    }
    // ensure no initial matches
    resolveInitialMatches();
    state.score = 0;
    state.level = 1;
    state.playerName = 'Игрок';
    saveState();
    renderAll();
  }
  function saveState(){
    localStorage.setItem(SAVE_KEY, JSON.stringify(state));
  }

  function resolveInitialMatches(){
    // remove matches by reassigning random until no matches
    while(true){
      const matches = findMatches(state.grid);
      if(matches.size === 0) break;
      for(const key of matches){
        const [r,c] = key.split(',').map(Number);
        state.grid[r][c] = randInt(GEM_TYPES);
      }
    }
  }

  /* --- Rendering --- */
  function renderAll(){
    // update score and level UI
    scoreEl.textContent = `Очки: ${state.score}`;
    levelTextEl.textContent = `Уровень: ${state.level}`;
    profileLevel.textContent = `Уровень ${state.level}`;
    const name = state.playerName || 'Игрок';
    nameInput.value = name;
    avatarInitial.textContent = name[0] ? name[0].toUpperCase() : 'U';
    // progress
    const need = levelThreshold(state.level);
    const prevNeed = levelThreshold(state.level-1) || 0;
    const pct = Math.min(100, Math.round(100 * (state.score - prevNeed) / (need - prevNeed)));
    levelProgressBar.style.width = pct + '%';

    // render board cells and gems
    boardEl.innerHTML = '';
    // create empty grid of cells
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.r = r; cell.dataset.c = c;
        // place gem element
        const gemType = state.grid[r][c];
        const gem = createGemElement(gemType, r, c);
        cell.appendChild(gem);
        boardEl.appendChild(cell);
      }
    }
  }

  function createGemElement(type, r, c){
    const g = document.createElement('div');
    g.className = 'gem type-' + type;
    g.dataset.r = r; g.dataset.c = c;
    // put svg shape (varied shapes)
    g.innerHTML = gemSVG(type);
    // position absolutely inside cell via CSS (it's absolute already)
    return g;
  }

  function gemSVG(type){
    // provide different shapes: diamond, round gem, hexagon, heart-ish, kite, star-like
    // use simple path shapes
    switch(type){
      case 0: // diamond
        return `<svg viewBox="0 0 100 100"><path d="M50 8 L88 50 L50 92 L12 50 Z"/></svg>`;
      case 1: // sapphire (rounded gem)
        return `<svg viewBox="0 0 100 100"><path d="M50 6 C78 6 94 24 94 52 C94 80 76 94 50 94 C24 94 6 80 6 52 C6 24 22 6 50 6 Z"/></svg>`;
      case 2: // hexagon (amber)
        return `<svg viewBox="0 0 100 100"><path d="M25 8 L75 8 L92 50 L75 92 L25 92 L8 50 Z"/></svg>`;
      case 3: // kite / elongated
        return `<svg viewBox="0 0 100 100"><path d="M50 6 L86 50 L50 94 L14 50 Z"/></svg>`;
      case 4: // twisted gem
        return `<svg viewBox="0 0 100 100"><path d="M50 10 L78 30 L90 64 L60 86 L22 76 L10 40 Z"/></svg>`;
      case 5: // star-ish
        return `<svg viewBox="0 0 100 100"><path d="M50 8 L60 40 L94 44 L66 64 L76 96 L50 76 L24 96 L34 64 L6 44 L40 40 Z"/></svg>`;
      default:
        return `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="40"/></svg>`;
    }
  }

  /* --- Matching logic --- */
  function findMatches(grid){
    // returns Set of "r,c" strings to remove
    const toRemove = new Set();
    // horizontal
    for(let r=0;r<ROWS;r++){
      let start=0;
      for(let c=1;c<=COLS;c++){
        if(c< COLS && grid[r][c] === grid[r][start]) continue;
        const len = c - start;
        if(len >=3){
          for(let k=start;k<c;k++) toRemove.add(`${r},${k}`);
        }
        start = c;
      }
    }
    // vertical
    for(let c=0;c<COLS;c++){
      let start=0;
      for(let r=1;r<=ROWS;r++){
        if(r< ROWS && grid[r][c] === grid[start][c]) continue;
        const len = r - start;
        if(len >=3){
          for(let k=start;k<r;k++) toRemove.add(`${k},${c}`);
        }
        start = r;
      }
    }
    return toRemove;
  }

  /* --- Swap + animations + game loop handling --- */
  let isBusy = false;

  async function attemptSwap(r1,c1,r2,c2){
    if(isBusy) return false;
    // must be adjacent
    const d = Math.abs(r1-r2) + Math.abs(c1-c2);
    if(d !== 1) return false;
    isBusy = true;
    // animate swap visuals
    const cellA = queryCell(r1,c1);
    const cellB = queryCell(r2,c2);
    const gemA = cellA.querySelector('.gem');
    const gemB = cellB.querySelector('.gem');
    if(!gemA || !gemB){ isBusy=false; return false; }

    // add moving class
    gemA.classList.add('moving'); gemB.classList.add('moving');

    // compute translate offset
    const dx = (c2 - c1) * (cellA.clientWidth + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 8);
    const dy = (r2 - r1) * (cellA.clientHeight + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 8);

    gemA.style.transform = `translate(${dx}px, ${dy}px)`;
    gemB.style.transform = `translate(${-dx}px, ${-dy}px)`;

    await wait(180);

    // remove transforms and replace DOM positions by swapping in grid and re-render
    gemA.classList.remove('moving'); gemB.classList.remove('moving');
    gemA.style.transform = ''; gemB.style.transform = '';

    // swap in state
    const gridCopy = deepCopyGrid(state.grid);
    [gridCopy[r1][c1], gridCopy[r2][c2]] = [gridCopy[r2][c2], gridCopy[r1][c1]];
    // check for matches
    const matches = findMatches(gridCopy);
    if(matches.size === 0){
      // invalid move -> swap back visually (we already swapped back in DOM; just animate small shake)
      // but to show swap-back, animate brief scale
      const a = queryCell(r1,c1).querySelector('.gem');
      const b = queryCell(r2,c2).querySelector('.gem');
      if(a && b){ a.classList.add('moving'); b.classList.add('moving'); a.style.transform='scale(0.96)'; b.style.transform='scale(0.96)'; await wait(140); a.style.transform=''; b.style.transform=''; a.classList.remove('moving'); b.classList.remove('moving'); }
      isBusy = false;
      return false;
    } else {
      // commit swap
      state.grid = gridCopy;
      await processMatchesAndGravity();
      saveState();
      isBusy = false;
      return true;
    }
  }

  function queryCell(r,c){
    return boardEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
  }

  function wait(ms){ return new Promise(res => setTimeout(res, ms)); }

  async function processMatchesAndGravity(){
    // main loop: find matches, animate removal, collapse, refill, repeat
    let chain = 0;
    while(true){
      const matches = findMatches(state.grid);
      if(matches.size === 0) break;
      chain++;
      // score: base 50 per gem times chain multiplier
      const gained = matches.size * 50 * chain;
      state.score += gained;
      scoreEl.textContent = `Очки: ${state.score}`;
      checkLevelUp();

      // animate removal: add class .remove to matched gem DOMs
      for(const key of matches){
        const [r,c] = key.split(',').map(Number);
        const cell = queryCell(r,c);
        if(!cell) continue;
        const gem = cell.querySelector('.gem');
        if(gem){
          gem.classList.add('remove');
        }
      }
      await wait(520); // match remove duration

      // actually remove gems from grid (set to null)
      for(const key of matches){
        const [r,c] = key.split(',').map(Number);
        state.grid[r][c] = null;
      }
      // visually clear matched elements
      for(const key of matches){
        const [r,c] = key.split(',').map(Number);
        const cell = queryCell(r,c);
        if(cell){
          // remove gem element(s)
          const gem = cell.querySelector('.gem');
          if(gem) gem.remove();
        }
      }
      await wait(40);

      // gravity: for each column, collapse nulls down
      for(let c=0;c<COLS;c++){
        let write = ROWS - 1;
        for(let r=ROWS-1;r>=0;r--){
          if(state.grid[r][c] !== null){
            state.grid[write][c] = state.grid[r][c];
            if(write !== r) state.grid[r][c] = null;
            write--;
          }
        }
        // fill new random at top
        for(let r=write;r>=0;r--){
          state.grid[r][c] = randInt(GEM_TYPES);
        }
      }

      // re-render board with falling animation
      await animateRefill();
      saveState();
      await wait(80); // small pause before next chain
    }
  }

  async function animateRefill(){
    // Re-render gems but animate vertical movement from prior positions
    // Strategy: for each cell, update DOM gem elements to reflect new grid, animating translateY from old position
    // Simplify: rebuild board but animate gems from above (for visual falling effect).
    boardEl.innerHTML = '';
    // create a matrix of "startRow" for each new gem to compute fall distance
    // For simplicity, make gems appear above and translate down
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.r = r; cell.dataset.c = c;
        const gem = createGemElement(state.grid[r][c], r, c);
        // start position: above by random offset
        gem.style.transform = `translateY(${ - (50 + 30 * (Math.random())) }px)`;
        gem.style.opacity = '0';
        cell.appendChild(gem);
        boardEl.appendChild(cell);
      }
    }
    // force reflow then animate to place
    await wait(20);
    const gems = boardEl.querySelectorAll('.gem');
    gems.forEach((g, i) => {
      const delay = (i % COLS) * 40 + Math.floor(i / COLS) * 20;
      g.style.transition = `transform 280ms cubic-bezier(.2,.9,.2,1) ${delay}ms, opacity 220ms ${delay}ms`;
      g.style.transform = '';
      g.style.opacity = '';
    });
    await wait(420 + COLS * 40);
    // cleanup transitions
    gems.forEach(g => g.style.transition = '');
  }

  function checkLevelUp(){
    // when score reaches next threshold, level++ and small animation
    const need = levelThreshold(state.level);
    if(state.score >= need){
      state.level++;
      levelTextEl.textContent = `Уровень: ${state.level}`;
      profileLevel.textContent = `Уровень ${state.level}`;
      // flash progress
      levelTextEl.animate([{transform:'scale(1)'},{transform:'scale(1.08)'}],{duration:250,iterations:2,direction:'alternate'});
    }
    // update progress
    const needNow = levelThreshold(state.level);
    const prevNeed = levelThreshold(state.level-1) || 0;
    const pct = Math.min(100, Math.round(100 * (state.score - prevNeed) / (needNow - prevNeed)));
    levelProgressBar.style.width = pct + '%';
  }

  /* --- Input: swipe / drag --- */
  let pointerStart = null; // {r,c,x,y}
  let pointerActiveGem = null;

  function attachInput(){
    // pointer events on board
    boardEl.addEventListener('pointerdown', onPointerDown);
    boardEl.addEventListener('pointermove', onPointerMove);
    boardEl.addEventListener('pointerup', onPointerUp);
    boardEl.addEventListener('pointercancel', onPointerUp);
    // also allow keyboard arrows to nudge selected gem (optional)
    boardEl.addEventListener('keydown', e => {
      // not implemented selection UI — skip
    });
  }

  function onPointerDown(e){
    if(isBusy) return;
    const targetCell = e.target.closest('.cell');
    if(!targetCell) return;
    const r = Number(targetCell.dataset.r), c = Number(targetCell.dataset.c);
    pointerStart = {r,c,x:e.clientX,y:e.clientY};
    pointerActiveGem = targetCell.querySelector('.gem');
    boardEl.setPointerCapture(e.pointerId);
    e.preventDefault();
  }

  function onPointerMove(e){
    if(!pointerStart || !pointerActiveGem || isBusy) return;
    const dx = e.clientX - pointerStart.x;
    const dy = e.clientY - pointerStart.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    // if small move, show slight translate
    pointerActiveGem.style.transform = `translate(${dx*0.2}px, ${dy*0.2}px) scale(1.04)`;
  }

  async function onPointerUp(e){
    if(!pointerStart || !pointerActiveGem) { pointerStart = null; pointerActiveGem = null; return; }
    const dx = e.clientX - pointerStart.x;
    const dy = e.clientY - pointerStart.y;
    const absX = Math.abs(dx), absY = Math.abs(dy);
    const threshold = 24; // minimal pixels to consider swipe
    // reset transform quickly
    pointerActiveGem.style.transform = '';
    if(Math.max(absX, absY) < threshold){
      // treat as tap - do nothing
      pointerStart = null; pointerActiveGem = null;
      return;
    }
    // decide direction
    let dr=0, dc=0;
    if(absX > absY){
      dc = dx > 0 ? 1 : -1;
    } else {
      dr = dy > 0 ? 1 : -1;
    }
    const r1 = pointerStart.r, c1 = pointerStart.c;
    const r2 = r1 + dr, c2 = c1 + dc;
    if(r2 <0 || r2 >= ROWS || c2 <0 || c2 >= COLS){
      pointerStart = null; pointerActiveGem = null;
      return;
    }
    // attempt swap
    await attemptSwap(r1,c1,r2,c2);
    pointerStart = null; pointerActiveGem = null;
  }

  /* --- Helpers / UI interactions --- */
  document.getElementById('tabGame').addEventListener('click', () => {
    toggleTab('game');
  });
  document.getElementById('tabProfile').addEventListener('click', () => {
    toggleTab('profile');
  });

  function toggleTab(name){
    const tabGame = document.getElementById('tabGame');
    const tabProfile = document.getElementById('tabProfile');
    const gameView = document.getElementById('gameView');
    const profileView = document.getElementById('profileView');
    if(name === 'profile'){
      tabProfile.classList.add('active'); tabGame.classList.remove('active');
      gameView.parentElement.style.display = 'none';
      profileView.style.display = 'flex';
    } else {
      tabProfile.classList.remove('active'); tabGame.classList.add('active');
      gameView.parentElement.style.display = 'flex';
      profileView.style.display = 'none';
    }
  }

  // name change
  nameInput.addEventListener('change', () => {
    state.playerName = nameInput.value || 'Игрок';
    avatarInitial.textContent = state.playerName[0].toUpperCase();
    saveState();
  });

  // initial run
  initState();
  attachInput();

  // convenience: click on a gem to try simple adjacent swap to the right (for mouse users) - optional
  boardEl.addEventListener('click', async (e) => {
    // ignored to avoid unexpected moves
  });

  // Enable keyboard: R to reset
  window.addEventListener('keydown', (e) => {
    if(e.key === 'r' || e.key === 'R'){
      if(confirm('Сбросить прогресс и начать заново?')){
        localStorage.removeItem(SAVE_KEY);
        initState();
      }
    }
  });

  // touch friendly: prevent scrolling on board
  boardEl.addEventListener('touchmove', e => e.preventDefault(), {passive:false});

  // Expose a debug function (in console) to print state
  window.match3State = () => state;

})();
</script>
</body>
</html>
